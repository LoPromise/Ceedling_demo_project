/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : test.sm
 */


/*!
 * \page StateDiagram
 * Page for StateDiagram
 * \dotfile test_sm.dot
 */


#include "Task.h"
#include "test_sm.h"

#define getOwner(fsm) (fsm)->_owner

static void TaskState_Done(struct testContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void TaskState_Start(struct testContext *const fsm, long timeslice)
{
    getState(fsm)->Default(fsm);
}

static void TaskState_Stopped(struct testContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void TaskState_Suspend(struct testContext *const fsm, int number)
{
    getState(fsm)->Default(fsm);
}

static void TaskState_Unblock(struct testContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void TaskState_Default(struct testContext *const fsm)
{
    State_Default(fsm);
}

#define TaskMap_Suspended_Done TaskState_Done
#define TaskMap_Suspended_Start TaskState_Start
#define TaskMap_Suspended_Stopped TaskState_Stopped
#define TaskMap_Suspended_Suspend TaskState_Suspend
#define TaskMap_Suspended_Unblock TaskState_Unblock
#define TaskMap_Suspended_Default TaskState_Default
#define TaskMap_Running_Done TaskState_Done
#define TaskMap_Running_Start TaskState_Start
#define TaskMap_Running_Stopped TaskState_Stopped
#define TaskMap_Running_Suspend TaskState_Suspend
#define TaskMap_Running_Unblock TaskState_Unblock
#define TaskMap_Running_Default TaskState_Default
#define TaskMap_Blocked_Done TaskState_Done
#define TaskMap_Blocked_Start TaskState_Start
#define TaskMap_Blocked_Stopped TaskState_Stopped
#define TaskMap_Blocked_Suspend TaskState_Suspend
#define TaskMap_Blocked_Unblock TaskState_Unblock
#define TaskMap_Blocked_Default TaskState_Default
#define TaskMap_Stopping_Done TaskState_Done
#define TaskMap_Stopping_Start TaskState_Start
#define TaskMap_Stopping_Stopped TaskState_Stopped
#define TaskMap_Stopping_Suspend TaskState_Suspend
#define TaskMap_Stopping_Unblock TaskState_Unblock
#define TaskMap_Stopping_Default TaskState_Default
#define TaskMap_Stopped_Done TaskState_Done
#define TaskMap_Stopped_Start TaskState_Start
#define TaskMap_Stopped_Stopped TaskState_Stopped
#define TaskMap_Stopped_Suspend TaskState_Suspend
#define TaskMap_Stopped_Unblock TaskState_Unblock
#define TaskMap_Stopped_Default TaskState_Default
#define TaskMap_DefaultState_Done TaskState_Done
#define TaskMap_DefaultState_Start TaskState_Start
#define TaskMap_DefaultState_Stopped TaskState_Stopped
#define TaskMap_DefaultState_Suspend TaskState_Suspend
#define TaskMap_DefaultState_Unblock TaskState_Unblock

#undef TaskMap_Suspended_Start
static void TaskMap_Suspended_Start(struct testContext *const fsm, long timeslice)
{

    setState(fsm, &TaskMap_Running);

}

const struct TaskState TaskMap_Suspended = {
    TaskMap_Suspended_Done,
    TaskMap_Suspended_Start,
    TaskMap_Suspended_Stopped,
    TaskMap_Suspended_Suspend,
    TaskMap_Suspended_Unblock,
    TaskMap_Suspended_Default,
    0
};

#undef TaskMap_Running_Done
static void TaskMap_Running_Done(struct testContext *const fsm)
{

    setState(fsm, &TaskMap_Stopped);

}

#undef TaskMap_Running_Suspend
static void TaskMap_Running_Suspend(struct testContext *const fsm, int number)
{
    struct Task *ctxt = getOwner(fsm);

    if (ctxt->isProcessorAvailable(number) == true &&
        ctxt->getConnection() == true) {
        /* No actions. */
        setState(fsm, &TaskMap_Suspended);
    }
    else {
        TaskMap_DefaultState_Suspend(fsm, number);
    }

}

const struct TaskState TaskMap_Running = {
    TaskMap_Running_Done,
    TaskMap_Running_Start,
    TaskMap_Running_Stopped,
    TaskMap_Running_Suspend,
    TaskMap_Running_Unblock,
    TaskMap_Running_Default,
    1
};

#undef TaskMap_Blocked_Unblock
static void TaskMap_Blocked_Unblock(struct testContext *const fsm)
{

    setState(fsm, &TaskMap_Suspended);

}

const struct TaskState TaskMap_Blocked = {
    TaskMap_Blocked_Done,
    TaskMap_Blocked_Start,
    TaskMap_Blocked_Stopped,
    TaskMap_Blocked_Suspend,
    TaskMap_Blocked_Unblock,
    TaskMap_Blocked_Default,
    2
};

#undef TaskMap_Stopping_Stopped
static void TaskMap_Stopping_Stopped(struct testContext *const fsm)
{

    setState(fsm, &TaskMap_Stopped);

}

const struct TaskState TaskMap_Stopping = {
    TaskMap_Stopping_Done,
    TaskMap_Stopping_Start,
    TaskMap_Stopping_Stopped,
    TaskMap_Stopping_Suspend,
    TaskMap_Stopping_Unblock,
    TaskMap_Stopping_Default,
    3
};

const struct TaskState TaskMap_Stopped = {
    TaskMap_Stopped_Done,
    TaskMap_Stopped_Start,
    TaskMap_Stopped_Stopped,
    TaskMap_Stopped_Suspend,
    TaskMap_Stopped_Unblock,
    TaskMap_Stopped_Default,
    4
};

#ifdef NO_TEST_SM_MACRO
void testContext_Init(struct testContext *const fsm, struct Task *const owner)
{
    FSM_INIT(fsm, &Task_Idle);
    fsm->_owner = owner;
}

void testContext_Done(struct testContext *const fsm)
{
    const struct TaskState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "Done");
    state->Done(fsm);
    setTransition(fsm, NULL);
}

void testContext_Start(struct testContext *const fsm, long timeslice)
{
    const struct TaskState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "Start");
    state->Start(fsm, timeslice);
    setTransition(fsm, NULL);
}

void testContext_Stopped(struct testContext *const fsm)
{
    const struct TaskState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "Stopped");
    state->Stopped(fsm);
    setTransition(fsm, NULL);
}

void testContext_Suspend(struct testContext *const fsm, int number)
{
    const struct TaskState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "Suspend");
    state->Suspend(fsm, number);
    setTransition(fsm, NULL);
}

void testContext_Unblock(struct testContext *const fsm)
{
    const struct TaskState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "Unblock");
    state->Unblock(fsm);
    setTransition(fsm, NULL);
}
#endif

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
